import datetime
import re
import getpass

# Code generation if we want to get all trees (and some even more than once)
def write_all_trees_to_file(source, target, env):
    n = int(env["NUM_THREADS_DEFAULT"])
    path = target
    print ("Generating all trees with %d nodes, writing to %s"%(n,path))
    def generate_all_trees(n):
        """Generates all trees with n+1 (unlabelled) nodes"""
        if n==1:
            yield [(1,0)]
            return
        for tree in generate_all_trees(n-1):
            for i in xrange(n):
                yield [(n,i)] + tree
    f = open(path, "w")
    f.write("// This is an autogenerated file.\n")
    f.write("// Please do not modify this file by hand.\n\n")
    f.write("#ifndef ALLTREES_H\n")
    f.write("#define ALLTREES_H\n\n")
    f.write("#define __E(a,b) pair<Task,Task>(Task(a),Task(b))\n\n")
    f.write("vector<vector<pair<Task,Task>>> alltrees = {\n")
    for t in generate_all_trees(n):
        f.write("    {\n")
        for (a, b) in t:
            f.write("        __E(%d,%d),\n"%(a,b))
        f.write("    },\n")
    f.write("};\n\n")
    f.write("#undef __E\n\n")
    f.write("#endif\n")
    f.close()

# version information
def create_version_info(*a,**b):
    print("Writing version information.")
    f = open(r"info.cpp", "r")
    lines = f.readlines()
    f.close()
    f = open(r"info.cpp", "w")
    for i in xrange(len(lines)):
        if lines[i].startswith("char date"):
            dt = datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S")
            lines[i] = "char date[] = \"%s\";\n"%(dt)
        if lines[i].startswith("char build"):
            buildno = int(re.search("\"([0-9]*)\"", lines[i]).group(1))
            lines[i] = "char build[] = \"%s\";\n"%(str(buildno+1))
        if lines[i].startswith("char builtby"):
            builtby = getpass.getuser()
            lines[i] = "char builtby[] = \"%s\";\n"%(builtby)
    f.writelines(lines)
    f.close()


# variables
vars = Variables()
vars.Add(EnumVariable("OPT", 
            "Optimization level can be set to 0, 1, 2 or 3", "0", 
            allowed_values=("0", "1", "2", "3")))
vars.Add("NUM_THREADS_DEFAULT", 
        "Number of threads. Possibly something between 1 and 20", "5")
vars.Add("NUM_PROCESSORS", "Number of processors.", "2")
vars.Add(EnumVariable("SIMPLE_ISOMORPHISM_CHECK", "Simple isomorphism check when computing successors.", 1,
            allowed_values=("0", "1")))
number_types = [(0, "float"), 
                (1, "double"), 
                (2, "rational<int>"), 
                (3, "rational<long>")]
vars.Add(EnumVariable("MYFLOAT", "Datatype for rational numbers:\n" 
            + "\n".join(["     %d %s"%(x) for x in number_types]), "0",
            allowed_values=("0", "1", "2", "3")))
vars.Add(EnumVariable("USE_SIMPLE_OPENMP", "Simple multithreading for computing topmost successors. Currently only working for value 0.", 0,
            allowed_values=("0", "1")))
vars.Add(EnumVariable("USE_CANONICAL_SNAPSHOT", "Use flyweight pattern to reduce amout of memory used at the price of (possibly only slightly) higher computation time.", 1,
            allowed_values=("0", "1")))

# we use C++11 (mainly to simplify some writing in C++)
env = Environment(variables = vars,
                  CXXFLAGS=["-std=c++0x", "-Wall", "-fopenmp", 
                            "-O${OPT}", 
                            "-g", # TODO: only if non-optimizing
                            "-DNUM_THREADS_DEFAULT=${NUM_THREADS_DEFAULT}",
                            #"-DNUM_PROCESSORS=${NUM_PROCESSORS}",
                            "-DSIMPLE_ISOMORPHISM_CHECK=${SIMPLE_ISOMORPHISM_CHECK}",
                            "-DMYFLOAT=${MYFLOAT}",
                            "-DUSE_SIMPLE_OPENMP=${USE_SIMPLE_OPENMP}",
                            "-DUSE_CANONICAL_SNAPSHOT=${USE_CANONICAL_SNAPSHOT}",
                            ], 
                  LIBS = ["boost_program_options",
                  ],
                  LINKFLAGS="-fopenmp",
                  build_dir = "build"
                 )
env.Append(NEW_VARIABLE = vars);

# TODO: code generation stuff
# code generation
# print "Writing all trees."
# env.Command("alltrees.h", "", write_all_trees_to_file)

# help
Help(vars.GenerateHelpText(env))

# main program
env.Command("info.cpp", "", create_version_info)
mainprog = env.Program(target="tasks", source=Glob("*.cpp"))
