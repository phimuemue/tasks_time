%%% thesis.tex --- 

%% Author: philipp@pmpc
%% Version: $Id: thesis.tex,v 0.0 2013/04/08 12:19:13 philipp Exp$

%%\revision$Header: /home/philipp/Documents/Uni/masterarbeit/thesis/thesis.tex,v 0.0 2013/04/08 12:19:13 philipp Exp$

\documentclass[letter]{report}

\usepackage[english]{babel}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{suffix}
\usepackage{stmaryrd}
\usepackage[left=2.5cm,right=2.5cm]{geometry}

\usetikzlibrary{shapes.multipart,chains}
\usetikzlibrary{positioning}
\usetikzlibrary{matrix}
\usetikzlibrary{automata}
\usetikzlibrary{external} 

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

\newtheorem{definition}{Definition}[chapter]
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{conjecture}{Conjecture}[chapter]

\newcommand{\p}[1]{Pr\left[#1\right]}
\newcommand{\alltasks}{{\mathbb T}}
\newcommand{\neededfor}{\rightarrow}
\WithSuffix\newcommand\neededfor*{\stackrel{*}{\rightarrow}}

\tikzstyle{task_cross}=[
    {path picture={ 
        \draw[black]
        (path picture bounding box.south east) -- 
        (path picture bounding box.north west) 
        (path picture bounding box.south west) -- 
        (path picture bounding box.north east);
      }
    }
]

\tikzstyle{task_scheduled}=[fill=white, draw=black, task_cross]

% \getwidthofnode will measure the width of the node given as its second
% parameter and store it into the first parameter.
\makeatletter
\newcommand\getwidthofnode[2]{%
    \pgfextractx{#1}{\pgfpointanchor{#2}{east}}%
    \pgfextractx{\pgf@xa}{\pgfpointanchor{#2}{west}}% \pgf@xa is a length defined by PGF for temporary storage. No need to create a new temporary length.
    \addtolength{#1}{-\pgf@xa}%
}
\makeatother

\begin{document}

% stuff to draw diagrams levelwise
\newcommand{\leveltop}{0}
\newcommand{\leveltopI}{0}
\newcommand{\leveltopII}{0}
\newcommand{\leveltopIII}{0}
\newcommand{\leveltopIIII}{0}
\newcommand{\leveltopIIIII}{0}
\newcommand{\leveltopIIIIII}{0}
\newcommand{\leveltopIIIIIII}{0}
\newcommand{\leveltopIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIIIIIIIIIIIIII}{0}
\newcommand{\leveltopIIIIIIIIIIIIIIIIIIIIIIIIIIIII}{0}

\include{theory/theory}

\chapter{First thoughts on implementation}
\label{chap:first-thoughts-on-implementation}

\section{Configuration DAG}
\label{sec:configuration-dag}

Initially we are dealing with an intree (i.e. each node has at most one successor) of tasks that have to be processed by a certain number of processors.

We will call the set of \emph{all} tasks $\alltasks$. If task $t_2$ can only be executed if $t_1$ already has been processed, we write $t_1 \neededfor t_2$. Moreover, we introduce a shorthand notation that allows us to ``chain'' several of these symbols: If there exist tasks $s_1,\dots,s_m$ ($m\in\mathbb N$), we write $t_1 \neededfor* t_2$ if we have $t_1 \neededfor s_1$ and $s_1 \neededfor s_2, s_2 \neededfor s_3, \dots, s_{m-1} \neededfor s_m$ and $s_m \neededfor t_2$ or if $t_1\neededfor t_2$ or if $t_1=t_2$.

\begin{definition}
  Let $\alltasks$ be a set of tasks, and $T \subseteq \alltasks$. We call $T$ an intree (of tasks) if there is one designated task $t_0\in\alltasks$ such that the following two conditions hold:
  \begin{eqnarray*}
    \forall  t \in T. & \quad t \neededfor* t_0 \\
    \forall  t \in T. & \quad t\neededfor s \Rightarrow s\in T
  \end{eqnarray*}
\end{definition}

\begin{definition}
  Let $T$ be an intree of tasks. Let $M\subseteq\alltasks$ be a set of tasks such that the following two conditions hold:
  \begin{itemize}
  \item $\forall t\in M.\, t \in T$
  \item $\forall t\in M.\, \nexists u \in T.\, u\neededfor t $
  \end{itemize}
  We then call the tuple $\left( T, M \right)$ a \emph{configuration}.
\end{definition}

\chapter{Drawing trees}
\label{chap:drawing-trees}

This is just a test chapter to see how we can draw the intrees and the snapshot DAGs.
\newsavebox{\nodebox}

\section{P2: A whole intree-DAG and its condensed counterpart}

\input{../0011123669hlf.tex}

%\input{examples/p2/001112566_with_condensed.tex}

\section{The current TikZ-file}

\input{../default.tex}

\include{p2/p2}

\chapter{Three Processors}
\label{chap:p3}

\input{p3/hlf_not_optimal}

\end{document}
