\chapter{Additional algorithms}
\label{sec:additional-algs}

\newcommand{\treegeq}[1][X]{\stackrel{\text{#1}}{\geq}}

\section{Computing equivalent snapshots}
\label{sec:algorithm-equivalent-snapshot}

As mentioned in section \ref{sec:intro-first-glance-schedules}, it is possible to combine certain snapshots into one single snapshot, thereby avoiding redundant computations. The requirements for two snapshots being equivalent have been discussed there.

It is a notable fact that we can determine in polynomial time (w.r.t. the number of nodes) whether two snapshots are equivalent. This computation involves foremost a check whether the two corresponding intrees are isomorphic. 

%While it seems to be quite hard to check isomorphism for general graphs (\todo{unbedingt Referenz!}), it is feasible for intrees.

While there currently is no known algorithm that checks isomorphism in polynomial time \emph{for general graphs} (see \cite{arora2009computational}), there is a simple algorithm for isomorphism of intrees. The idea behind this algorithm is to recursively sort the predecessors of a task according to the number of their respective predecessors. An early description of this algorithm can be found e.g. in \cite{aho1974design}. We can easily adapt this isomorphism check to our needs in the sense that we can construct an algorithm that constructs a ``canonical snapshot'', and all equivalent snapshots are converted to exactly this canonical snapshot.

One thing to keep in mind is that we have to explicitly take care of the currently scheduled tasks, i.e. we have to adopt the algorithm to distinguish between scheduled and unscheduled tasks.

\subsection{The algorithm}
\label{sec:algorithm-equiv-snapshots-actual-algo}

The algorithm basically relies on an ordering of intrees (there are of course many possible, but we use a simple one).

\begin{definition}[Ordering of intrees with preferred tasks]
  We introduce an ordering denoted by $\treegeq$. For two intrees $I_1$ and $I_2$ and a set $X$ of tasks, we define $I_1 \treegeq I_2$ inductively. 
  \begin{itemize}
  \item If both $I_1$ and $I_2$ consist only of a root, we have $I_1 \treegeq I_2$ if and only if the root of $I_1$ is in $X$ and the root of $I_2$ is not in $X$.
  \item If the root of $I_1$ has less predecessors than the root of $I_2$, then $I_1 \treegeq I_2$.
  \item If the root of $I_1$ has the same number $r$ of predecessors as the root of $I_2$, we sort the corresponding predecessors $p_1,\dots,p_r$ resp. $q_1,\dots,q_r$ (in $I_1$ resp. $I_2$ according to $\treegeq$). Then, if $p_i \treegeq q_i \forall i\in\{1,2,\dots,r \}$, we have $I_1 \treegeq I_2$.
  \end{itemize}
\end{definition}

\todo{Examples!}

The algorithm recursively sorts the tasks in the intree according to the ordering $\treegeq$. It is shown in algorithm \ref{alg:compute-canonical-snapshot}.

\begin{algorithm}
  \begin{algorithmic}
    \Procedure{CanonicalSnapshot}{$s$} \Comment{Returns the canonical snapshot for snapshot $s$}
    \State $t \gets s.intree$ \Comment{Retrieve root of intree}
    \State $X \gets s.scheduled$ \Comment{Retrieve scheduled tasks}
    \State \textbf{return} \Call{CanonicalIntree}{$t, X$} 
    \EndProcedure
    \Statex
    \Procedure{CanonicalIntree}{$t, X$}\Comment{$t$: a (sub)tree, $X$: set of scheduled tasks}
    \State $r \gets t.root$ \Comment{Retrieve root of subtree}
    \State $CanonicalPredecessors \gets 
           \left\{ \Call{CanonicalIntree}{c, X} \mid c \in r.predecessors \right\}$
    \State \textbf{return} root with predecessors in $CanonicalPredecessors$ in sorted order according to $\treegeq$
    \EndProcedure
    \Statex
  \end{algorithmic}
  \caption{Computing canonical snapshots for a snapshot $s$ containing the corresponding intree and the tasks that are currently scheduled (as defined in section \ref{sec:processing-an-intree-of-tasks}).\todo{Algorithmus verbessern.}}
  \label{alg:compute-canonical-snapshot}
\end{algorithm}

\todo{Algorithmus, der equiv. snaps / bzw. canonical snaps berechnet zeigen.}\todo{Laufzeit!}

\subsection{Additional approaches}
\label{sec:algorithm-canonical-snap-additional-approaches}

Unfortunately, computing canonical snapshots has a major impact on the overal performance of our program, which is why we tried other approaches to tackle this problem. For completeness, we will explain them shortly. Unfortunately, they did not work out as good as expected, but maybe they are helpful for future work. In this section, we focus on the part concerning the computation of \emph{canonical intrees} (i.e. we do not distinguish between scheduled and non-scheuled leaves).

\begin{description}
\item[Tree sequence] Most of the time, we are generating a certain subtree and want to know the canonical intree of it. We tried exploiting the fact that we already could \emph{start} with a canonical intree. That is, we tried to construct the tree sequence of a canonical subtree by just examining the tree sequence of the original intree. Sadly, we could not devise a simple pattern that works as a general rule.\todo{Example where equiv intrees yield drastically different sequences.}
\item[Matula numbers] Intrees and their encodings have of course already been subject to research. One example is shown in \cite{matula1968natural}, where a (more or less) natural bijection between intrees and natural numbers, the so-called \emph{Matula numbers}, is shown.\todo{Short description.} While this description could lead to very elegant algorithms, it does not come in handy in practice because the matula numbers can be very big (more than 32 bit needed for matula numbers of 15-node intrees).
\end{description}

\section{Enumerating all intrees with a certain number of nodes}
\label{sec:enumerating-all-intrees}

It is clear that the number of intrees (more precisely, the number of unlabelled rooted trees) with exactly $n$ nodes is exponential in $n$ \todo{proof}. However, for experimental purposes, it is convenient to have an algorithm that is capable of enumerating all these intrees. The main thing that should be kept in mind is that we do \emph{not} generate isomorphic intrees over and over again.

We now show an algorithm to generate \emph{all} intrees with a certain number of nodes (called $n$) up to isomorphism. This algorithm is based on the following two facts: 

\begin{itemize}
  \item The overall root can have any amount of children between 1 and $n-1$. If it has only 1 child, the corresponding predecessor intree must contain exactly $n-1$ vertices. If it has exactly $n-1$ children, each predecessor intree contains exactly 1 vertex. All the cases in between admit several possibilities \todo{Worth stating exact stuff here?}.
  \item If the overall root of the intree with $n$ verices has exactly $r$ predecessors (with $r \in \left\{ 1,2,\dots,n-1 \right\}$, as stated before), then the sum of the vertices with in the predecessor intrees is exactly $n-1$. Moreover, let us denote the predecessor intrees by $T_1,T_2,\dots,T_r$ and call $n_i$ the number of vertices in predecessor intree $T_i$ for all $i\in\left\{1,2,\dots,r \right\}$. Without loss of generality, we can assume $1 \leq n_1 \leq n_2 \leq n_3 \leq \dots \leq n_r$\todo{How many of these \emph{partitions} are there?}.
\end{itemize}

We can exploit these two facts to construct a recursive algorithm which is described in algorithm \ref{alg:generate-intrees}. This algorithm enumerates all intrees with exactly $n$ vertices. It does so by traversing all tuples $(n_1,\dots,n_r)$ fulfilling
\begin{equation*}
  n_1 + n_2 + \dots + n_r = n-1 \quad \text{ and } \quad 1\leq n_1\leq n_2\leq\dots\leq n_r.
\end{equation*}
It then generates all combinations of predecessor intrees $(p_1,\dots,p_r)$ whose respective number of nodes are $n_1,\dots,n_r$. The algorithm thereby omits duplicate combinations. This can easily be acchieved by defining an order $\left(\treegeq\right)$ on intrees as follows ($t_1$ and $t_2$ being two intrees):

\begin{equation}
  \label{eq:definition-treegeq}
  t_1 \treegeq t_2 \equiv (\text{$t_1$ has more vertices than $t_2$}) \vee \exists k \in \left\{ 1,2,\dots,r \right\}. \left( p_{1,k} \treegeq p_{2,k} \wedge \forall i<k. p_{1,i}=p_{2,i} \right)
\end{equation}


\begin{algorithm}
  \begin{algorithmic}
    \Procedure{GenerateIntrees}{$n$} \Comment{Returns the set of all intrees with exactly $n$ vertices}
      \If{$n=1$} 
        \State \textbf{return} $\left\{ \tikz{\fill(0,0) circle (0.1cm);} \right\}$ \Comment{Base case: Intree with just 1 vertex}
      \EndIf
      \State $R \gets \left\{  \right\}$ \Comment{Variable for result}
      \For{$(n_1,\dots,n_r)
            \in 
            \left\{ (n_1,\dots,n_r) \in \naturals^r \mid 
              1 \leq r < n \wedge
              1 \leq n_1 \leq n_2 \leq \dots \leq n_r
            \right\}$}
        \State $P \gets$ (\Call{GenerateIntrees}{$n_1$},\dots,\Call{GenerateIntrees}{$n_r$}) \Comment{Predecessor intrees}
        \For{$(p_1,\dots,p_r) \in P[1] \times P[2] \times \dots \times P[r]$}
          \If{$p_1 \treegeq p_2 \treegeq \dots \treegeq p_r$} \Comment{No duplicates}
          \State $R \gets R \cup \Call{CombinePredecessorIntrees}{p_1,\dots,p_r}$
          \EndIf
        \EndFor
      \EndFor
      \State \textbf{return} $R$
    \EndProcedure
    \Statex
    \Procedure{CombinePredecessorIntrees}{$p_1,\dots,p_r$}
    \State \textbf{return} $\left\{
      \tikz[baseline=(current bounding box.center)]{
        \fill (-0.5,0)circle(0.1cm);
        \node(root) at (-0.5,0){};
        \node[circle](1) at (-2,1) {$p_1$};
        \node[circle](2) at (-1,1) {$p_2$};
        \node[circle](p) at (0,1) {...};
        \node[circle](r) at (1,1) {$p_r$};
        \draw[-] (1) -- (root);
        \draw[-] (2) -- (root);
        \draw[-] (r) -- (root);
      }
      \right\} $
      \Comment{New root with predecessor intrees $p_1,\dots,p_r$}
    \EndProcedure
  \end{algorithmic}
  \caption{Generating all intrees up to isomorphism}
  \label{alg:generate-intrees}
\end{algorithm}


%%% Local Variables:
%%% TeX-master: "../thesis.tex"
%%% End: 